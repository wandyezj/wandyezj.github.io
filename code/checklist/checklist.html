<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Checklist</title>
    <link id="favicon" rel="shortcut icon" href="" type="image/svg">
    <!-- 'data:image/svg+xml,<svg id="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><circle cx="8" cy="8" r="8" fill="white"/><text x="50%" y="100%" text-anchor="middle" font-size="1em">%F0%9F%97%B8</text></svg>'-->
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <!--
        https://content-security-policy.com/script-src/
        remove unsafe-inline
        replace this with a hash of the script
        <meta http-equiv="Content-Security-Policy"
         content="default-src 'self'">
        

        cat ./checklist.js | openssl sha256 -binary | openssl base64
        script-src 'sha512-HASH'

        https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin

        <script src="checklist.js" integrity="sha512-HASH" crossorigin="anonymous"></script>

        For normal development use 'self' 'unsafe-inline'

        Hashes
            - main script tag
    -->
    <!--
        img-src is for the favicon
    -->
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none' ; style-src 'unsafe-inline' ; img-src 'sha256-+DtLlqnWKiFJtCffXhUE0UzZWfHaNwwHz3koyEK+r+8='; script-src 'unsafe-inline'">

    <!-- Content Security Policy for production-->
    <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline' ; script-src 'sha256-kNQ844ZEH9AlmYG2y/K2f1z1Jnh+OJS+aLF6MpUWix8=' "> -->

    <!-- development - can be convenient to refresh automatically (every 30 seconds)-->
    <!-- <meta http-equiv="refresh" content="30"> -->

</head>

<body>

    <p>
        <svg id="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16">
            <!-- <rect width="100%" height="100%" fill="green" /> -->
            <circle cx="8" cy="8" r="8" fill="white" />
            <text x="50%" y="100%" text-anchor="middle" font-size="1em">ðŸ—¸</text>
        </svg>
        Checklist
    </p>

    <!-- Edit configuration that describes the document -->
    <div id="div_edit"
        style="background-color: rgba(0, 0, 0, 0.1);position: absolute;top:0%; bottom:0; left:0%;right:0%;" hidden>

        <button id="button_edit_cancel" style="
                float: left;
                padding: 10px 20px;
                ">Cancel</button>

        <button id="button_edit_save" style="
                float: right;
                padding: 10px 20px;
                ">Save</button>



        <!-- Text area can contain default markdown configuration, does this require generation of md from json configuration? or should it just show the json? -->
        <textarea id="textarea_edit" style="
                position:relative; top:0%;
                display: block;
                margin-left: auto;
                margin-right: auto;" cols="100" rows="80">
        </textarea>
    </div>

    <div id="div_controls">

        <p>Edit Configuration</p>
        <button id="button_edit_markdown">markdown</button>
        <button id="button_edit_json">json</button>
        <br>

        <p>URL</p>
        <button id="button_save_url">Save</button>
        <button id="button_load_url">Load</button>
        <button id="button_clear_url">Clear</button>
        <button id="button_share_url">Share</button>
        <br>

        <p>Save File</p>
        <button id="button_save_file_markdown">md</button>
        <button id="button_save_file_json">json</button>
        <button id="button_save_file_text">txt</button>
        <button id="button_save_file_svg">svg</button>
        <br>

        <p>Load File</p>
        <input id="input_load_file" type="file" accept=".json,.md,.txt,.svg">
    </div>

    <div id="div_browser_info">
        <p id="p_browser_not_supported_message" hidden>This browser is not supported, please use the latest version of
            <a href="https://www.microsoft.com/en-us/edge">Edge</a>.
        </p>
    </div>

    <!-- Configuration Placeholder with actual actions -->
    <div id="div_configuration"></div>

    <br>
    <div id="div_configuration_svg"></div>


    <script>

        //#region "definitions"

        /**
         * Possible Configuration Input Types
         * @readonly
         * @enum {string}
         */
        const ConfigurationInputType = {
            /**
             * @readonly
             * @type {"checkbox"}
             * A checkbox
             * linked state can only be true or false
             */
            Checkbox: "checkbox",

            /**
             * @readonly
             * @type {"likert"}
             * A likert
             * a likert state is one of the likert values
             */
            Likert: "likert"
        }

        /**
         * A configuration
         * @typedef {Object} Configuration
         * @property {string} title - title
         * @property {string} description - description
         * @property {Object.<string,ConfigurationConfig>} configs - configs
         * @property {ConfigurationItem[]} items - items
         * @property {Object.<string, ConfigurationState} state - state: id -> value
         */

        /**
         * A configuration state
         * @typedef {Object} ConfigurationState
         * @property {boolean?} checkbox - checkbox state is checked or unchecked
         * @property {string?} likert - likert state selected
         * 
         */

        /**
         * Input Type
         * @typedef {"checkbox"|"likert"} InputType
         */

        /**
         * A configuration item
         * @typedef ConfigurationItem
         * @property {string} id - unique id for the item, used to reference the state
         * @property {string} title - displayed
         * @property {string} description - explanation for the item
         * @property {InputType} input - input type from limited set of: {"checkbox"}
         * @property {string?} configId - config id, used to reference the relevant formatting config
         */

        /**
         * A configuration config - used to style elements
         * @typedef ConfigurationConfig
         * @property {string} id - unique id for the config
         * @property {ConfigurationConfigCheckbox} checkbox - checkbox configuration
         * @property {ConfigurationConfigLikert} likert - likert configuration
         * 
         */

        /**
         * A configuration config checkbox configuration - used to style a checkbox element
         * @typedef ConfigurationConfigCheckbox
         * @property {ConfigurationConfigCheckboxState} checked - checked state
         * @property {ConfigurationConfigCheckboxState} unchecked - unchecked state
         */

        /**
         * @typedef ConfigurationConfigCheckboxState
         * @property {string} color - HTML color
         */


        /**
         * A configuration config likert configuration - used to configure and style a likert element
         * @typedef ConfigurationConfigLikert
         * @property {ConfigurationConfigLikertOption[]} options - order of likert options
         */

        /**
        * A configuration config likert configuration option - used to configure and style a likert options
        * @typedef ConfigurationConfigLikertOption
        * @property {string} value - likert option value, used to pick option
        * @property {string} description - likert options descriptions
        * @property {string} color - HTML color
        */

        // place on click handler on the svg
        /**
         * Callback function for handling clicking of an sve element
         * @callback onclickSvgElement
         * @param {string} id - id of the clicked element
         * @param {InputType} input - type of input
         */

        //#endregion "definitions"


        //#region "default configurations"

        // whitespace matters
        const defaultConfigurationMarkdown = `
# example title

> example title description

- [ ] example item
    > example item description

- [x] example item
    > example item description duplicate

- [ ] example item other
    > example item description

- (likert) [always] some likert

- (likert) another likert

- (likert) with description
    > likert description

- (likert) [] empty value likert


\`\`\`config
{
    "id":"default",
    "checkbox" : {
        "checked": {
            "color":"pink"
        },
        "unchecked": {
            "color":"white"
        }
    },
    "likert": {
        "options":[
            {
                "value":"always",
                "description":"strongly agree",
                "color":"lime"
            },
            {
                "value":"mostly",
                "description":"agree",
                "color":"lightcyan"
            },
            {
                "value":"unknown",
                "description":"neutral",
                "color":"white"
            },
            {
                "value":"rarely",
                "description":"disagree",
                "color":"yellow"
            },
            {
                "value":"never",
                "description":"strongly disagree",
                "color":"red"
            }
        ]
    }
}
\`\`\`


`;

        //#endregion "default configurations"

        //#region "markdown"

        /**
         * Markdown Configuration Delimiters
         * @readonly
         * @enum {string}
         */
        const MarkdownConfigurationDelimiter = {

            /**
             * start list
             * @readonly
             * @type {"string"}
             */
            ListTitle: "# ",

            /**
             * start list description
             * @readonly
             * @type {"string"}
             */
            ListDescription: "> ",

            /**
             * start list checkbox checked
             * @readonly
             * @type {"string"}
             */
            ListItemCheckboxUnchecked: "- [ ] ",

            /**
             * start list checkbox unchecked
             * @readonly
             * @type {"string"}
             */
            ListItemCheckboxChecked: "- [x] ",

            /**
             * start list likert
             * @readonly
             * @type {"string"}
             */
            ListItemLikert: "- (likert) ",

            /**
             * list item likert value start
             * @readonly
             * @type {"string"}
             */
            ListItemLikertValueStart: "[",

            /**
             * list item likert value end
             * @readonly
             * @type {"string"}
             */
            ListItemLikertValueEnd: "] ",

            /**
             * list description start
             * @readonly
             * @type {"string"}
             */
            ListItemDescription: "    > ",

            /**
             * list config start
             * @readonly
             * @type {"string"}
             */
            ListConfigStart: "```config",

            /**
             * list config end
             * @readonly
             * @type {"string"}
             */
            ListConfigEnd: "```",

        }

        /**
         * create json configuration from a markdown description
         * @param {string} markdownInput
         */
        function parseMarkdownToConfiguration(markdownInput) {
            const markdown = markdownInput.trim()

            const lines = markdown.split("\n");
            // Could scrub empty lines for utility, but then need a mapping of lines to original line numbers for errors

            /**
             * Title for the whole list
             */
            let listTitle = undefined;

            /**
             * description for the whole list
             */
            let listDescription = undefined;

            /**
             * @type {Object.<string,ConfigurationConfig>}
             */
            const listConfigs = {};

            /**
             * items in the list
             * @type {ConfigurationItem[]}
             */
            const listItems = [];

            /**
             * state of each item
             * @type {Object.<string, ConfigurationState>}
             */
            const state = {};

            /**
             * @type {string[]}
             */
            const itemIds = [];

            /**
             * All errors parsing the markdown configuration
             * @type {string[]}
             */
            const errors = [];

            // Delimiters
            const delimiterListTitle = MarkdownConfigurationDelimiter.ListTitle;
            const delimiterListDescription = MarkdownConfigurationDelimiter.ListDescription;
            const delimiterListItemCheckboxUnchecked = MarkdownConfigurationDelimiter.ListItemCheckboxUnchecked;
            const delimiterListItemCheckboxChecked = MarkdownConfigurationDelimiter.ListItemCheckboxChecked;
            const delimiterListItemLikert = MarkdownConfigurationDelimiter.ListItemLikert;
            const delimiterListItemLikertValueStart = MarkdownConfigurationDelimiter.ListItemLikertValueStart;
            const delimiterListItemLikertValueEnd = MarkdownConfigurationDelimiter.ListItemLikertValueEnd;
            const delimiterListItemDescription = MarkdownConfigurationDelimiter.ListItemDescription;
            const delimiterListConfigStart = MarkdownConfigurationDelimiter.ListConfigStart;
            const delimiterListConfigEnd = MarkdownConfigurationDelimiter.ListConfigEnd;


            for (let i = 0; i < lines.length; i++) {
                // Get all lines before and after
                const linePrevious = i > 0 ? lines[i - 1] : undefined;
                let line = lines[i];
                const lineNext = i + 1 < lines.length ? lines[i + 1] : undefined;
                //console.log(line);

                const isListItemCheckboxUnchecked = line.startsWith(delimiterListItemCheckboxUnchecked);
                const isListItemCheckboxChecked = line.startsWith(delimiterListItemCheckboxChecked);

                const isListItemCheckbox = isListItemCheckboxUnchecked || isListItemCheckboxChecked;

                const isListItemLikert = line.startsWith(delimiterListItemLikert);

                const isListItem = isListItemCheckbox || isListItemLikert;

                // parse the line
                if (line.startsWith(delimiterListTitle)) {
                    // List Title
                    if (listTitle === undefined) {
                        listTitle = line.substring(delimiterListTitle.length).trim();
                    } else {
                        console.error(`line [${i}]: duplicate list title - only a single list title may be defined`);
                    }

                    // scroll through empty lines
                    line = lineNext;
                    while (line !== undefined && line.trim() === "") {
                        i++;
                        line = i < lines.length ? lines[i] : undefined;
                    }

                    // List Description
                    // Must be next line after title
                    if (line !== undefined && line.startsWith(delimiterListDescription)) {
                        listDescription = line.substring(delimiterListDescription.length).trim();
                        // already parsed line go to next
                        i++;
                    }

                } else if (isListItem) {

                    let itemTitle = undefined;
                    let itemInput = undefined;
                    let itemValue = undefined;

                    // List Item Checkbox

                    if (isListItemCheckbox) {
                        itemTitle = line.substring(delimiterListItemCheckboxUnchecked.length).trim();
                        itemInput = ConfigurationInputType.Checkbox;
                        itemValue = isListItemCheckboxChecked;
                    }


                    // List Item Likert
                    if (isListItemLikert) {
                        itemTitle = line.substring(delimiterListItemLikert.length).trim();
                        itemInput = ConfigurationInputType.Likert;
                        // How to store the value as part of the item?
                        // undefined will be removed from stringify
                        itemValue = null;

                        // value can be specified between delimiters
                        const valueStart = itemTitle.indexOf(delimiterListItemLikertValueStart);
                        const valueEnd = itemTitle.indexOf(delimiterListItemLikertValueEnd);

                        if (valueStart === 0 && valueEnd > 0) {
                            itemValue = itemTitle.substring(valueStart + delimiterListItemLikertValueStart.length, valueEnd);
                            itemTitle = itemTitle.substring(valueEnd + delimiterListItemLikertValueEnd.length);

                            // consider empty to be null value
                            if (itemValue === "") {
                                itemValue = null;
                            }
                        }
                    }

                    let itemDescription = undefined;

                    if (lineNext !== undefined && lineNext.startsWith(delimiterListItemDescription)) {
                        // List Item Description
                        itemDescription = lineNext.substring(delimiterListItemDescription.length).trim();

                        // Already parsed the line go to next
                        i++;
                    }

                    // mapping is imperfect since it filters characters
                    const itemBaseId = titleToId(itemTitle);
                    const itemId = toUniqueId(itemBaseId, itemIds);
                    itemIds.push(itemId);

                    listItems.push({
                        id: itemId,
                        title: itemTitle,
                        description: itemDescription,
                        input: itemInput,
                        configId: "default"
                    });

                    state[itemId] = { [itemInput]: itemValue };

                } else if (line.startsWith(delimiterListConfigStart)) {

                    const configStartLine = i;

                    /**
                     * All lines in the config section
                     * does not include the line that starts and ends the configuration
                     * @type {string[]}
                     */
                    const configLines = [];

                    /**
                     * did the config have a proper end before we ran out of lines?
                     */
                    let incompleteConfig = false;

                    while (true) {

                        i++;

                        if (i >= lines.length) {
                            // ran out of lines
                            incompleteConfig = true;
                            break;
                        }

                        line = lines[i];

                        if (line.startsWith(delimiterListConfigEnd)) {
                            // end of the config section
                            break;
                        }

                        configLines.push(line);
                    }

                    if (incompleteConfig) {
                        const error = `line [${configStartLine}]: config starting on the line has no end`;
                        errors.push(error);

                    } else {
                        const completeConfig = configLines.join("\n")
                        //console.log(completeConfig);

                        /**
                         * @type {ConfigurationConfig}
                         */
                        let config = undefined
                        try {
                            config = JSON.parse(completeConfig)
                        } catch (e) {
                            const error = `line [${configStartLine}]: config starting on the line is not valid JSON : ${e}`;
                            errors.push(error);
                        }


                        if (config) {
                            // TODO: validate config

                            const { id } = config;

                            // check config Id
                            if (id === undefined) {
                                const error = `line [${configStartLine}]: config starting on the line is missing an id property`;
                                errors.push(error);
                            } else if (typeof id !== "string") {
                                const error = `line [${configStartLine}]: config starting on the line is not a string`;
                                errors.push(error);
                            } else if (listConfigs.hasOwnProperty(id)) {
                                const error = `line [${configStartLine}]: config starting on the line has duplicate id of another config, config ids must be unique`;
                                errors.push(error);
                            } else {
                                // Add config
                                listConfigs[id] = config;
                            }
                        }
                    }

                } else {
                    // Unknown What is this?
                    if (line !== "") {
                        const error = `line [${i}]: unknown value [${line}]`
                        console.error(error);
                        errors.push(error);
                    }
                }
            }

            if (errors.length > 0) {
                throw new Error(`Errors in Markdown configuration:\n ${errors.join("\n")}`);
            }

            // Assemble configuration Json
            const configurationJson = {
                title: listTitle,
                description: listDescription,
                items: listItems,
                configs: listConfigs,
                state,
            }

            return configurationJson;
        }

        /**
         * Map item title to id
         * id can only consist of lowercase letters, numbers, and underscores
         * converts uppercase to lowercase
         * removes duplicate spaces and replaces the space with an underscore
         * @param {string} title - convert an items title into an id
         */
        function titleToId(title) {
            const characters = Array.from(title.toLowerCase());

            // characters allowed in an identifier
            const alphabet = "abcdefghijklmnopqrstuvwxyz";
            const numbers = "0123456789";
            const space = " ";

            const valid = alphabet + numbers + space;

            const validCharacters = Array.from(valid);

            // filter out invalid characters, remove duplicate spaces, map spaces to underscores
            const idArray = characters
                .filter((c) => validCharacters.includes(c))
                .filter((c, index, array) =>
                    // no duplicate spaces
                    c !== space || (c === space && index - 1 >= 0 && array[index - 1] !== space)
                ).map((c) => c === space ? "_" : c);

            const id = idArray.join("");
            return id;
        }

        /**
         * create unique id based off a baseId, given the set of existing Ids
         * @param {string} baseId - base id to make a unique id out of
         * @param {string[]} existingIds - existing set of unique ids to make sure the returned id does not clash
         * @returns {string} unique id not present in existingIds
         */
        function toUniqueId(baseId, existingIds) {
            let itemId = baseId;

            // id must not already be present
            // if id is already present attach a numeric count to the end to make it unique
            let idCount = 0;
            while (-1 !== existingIds.findIndex((id) => id === itemId)) {
                idCount++;
                itemId = baseId + "_" + idCount;
            }

            return itemId;
        }

        /**
         * convert configuration to markdown text
         * @param {Configuration} configuration
         * @returns {string}
         */
        function getConfigurationToMarkdown(configuration) {

            // Tokens
            const delimiterListTitle = MarkdownConfigurationDelimiter.ListTitle;
            const delimiterListDescription = MarkdownConfigurationDelimiter.ListDescription;
            const delimiterListItemCheckboxUnchecked = MarkdownConfigurationDelimiter.ListItemCheckboxUnchecked;
            const delimiterListItemCheckboxChecked = MarkdownConfigurationDelimiter.ListItemCheckboxChecked;
            const delimiterListItemLikert = MarkdownConfigurationDelimiter.ListItemLikert;
            const delimiterListItemLikertValueStart = MarkdownConfigurationDelimiter.ListItemLikertValueStart;
            const delimiterListItemLikertValueEnd = MarkdownConfigurationDelimiter.ListItemLikertValueEnd;
            const delimiterListItemDescription = MarkdownConfigurationDelimiter.ListItemDescription;
            const delimiterListConfigStart = MarkdownConfigurationDelimiter.ListConfigStart;
            const delimiterListConfigEnd = MarkdownConfigurationDelimiter.ListConfigEnd;

            const { title, description, configs, items, state } = configuration;

            // title
            const piecesTitle = [
                `${delimiterListTitle}${title}`,
                "",
                `${delimiterListDescription}${description}`,
            ];


            // items
            const piecesItems = items.map((item) => {
                const { input, id, title, description } = item;

                // everything uses the same way of declaring a description
                const markdownDescription = description === undefined ? "" : `\n    > ${description}`;

                if (input === ConfigurationInputType.Checkbox) {
                    const value = state[id].checkbox;
                    return `${value ? delimiterListItemCheckboxChecked : delimiterListItemCheckboxUnchecked}${title}${markdownDescription}`;

                } else if (input === ConfigurationInputType.Likert) {
                    const value = state[id].likert;
                    return `${delimiterListItemLikert}${value === null ? "" : `${delimiterListItemLikertValueStart}${value}${delimiterListItemLikertValueEnd}`}${title}${markdownDescription}`;
                }

                throw new Error(`Invalid input [${input}]`);
            });

            // configs
            const piecesConfigs = Object.getOwnPropertyNames(configs).map((name) => {
                const config = JSON.stringify(configs[name], undefined, 4);
                return `${delimiterListConfigStart}\n${config}\n${delimiterListConfigEnd}`;
            });

            const pieces = [piecesTitle.join("\n"), piecesItems.join("\n\n"), ...piecesConfigs];
            const body = pieces.join("\n\n") + "\n"; // end in newline

            return body;
        }

        //#endregion "markdown"

        /**
         * currently loaded configuration
         * should only be used by loadConfiguration and getConfigurationSnapshot
         * @type {Configuration|undefined}
         */
        let globalConfiguration = undefined;

        /**
         * @param {Configuration} configuration
         */
        function loadConfiguration(configuration) {
            console.log("loadConfiguration");
            console.log(configuration);
            console.log(getConfigurationToMarkdown(configuration));
            globalConfiguration = configuration;
            onConfigurationUpdated();
        }

        /**
         * Get a snapshot of the current global configuration
         * a snapshot is simply a configuration with the current state of the HTML attached
         * @returns {Configuration} snapshot of configuration
         */
        function getConfigurationSnapshot() {
            const configuration = globalConfiguration;

            // clone configuration
            const s = JSON.stringify(configuration);

            /**
             * @type {Configuration}
             */
            const snapshot = JSON.parse(s);


            return snapshot
        }

        function assertString(variable) {
            if (typeof variable !== 'string') {
                throw new TypeError('variable must be a string')
            }
        }

        /**
         * check that string is only made up of valid characters
         * @param {string} check - string to check
         * @param {string} valid - string of valid characters
         */
        function assertStringRange(check, valid) {
            assertString(check);
            assertString(valid);

            const validCharacters = Array.from(valid);

            // filter out invalid characters, remove duplicate spaces, map spaces to underscores
            const invalid = Array.from(check).filter((c) => !validCharacters.includes(c));
            if (invalid.length > 0) {
                throw new RangeError(`Invalid characters in string: [${invalid.join("")}]`);
            }
        }


        //#region "hextext"
        /**
         * converts an ArrayBuffer to hexText
         * @param {ArrayBuffer} buffer - ArrayBuffer
         * @returns {string}
         */
        function convertBufferToHex(buffer) {
            // https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
            return [...new Uint8Array(buffer)]
                .map(x => x.toString(16).padStart(2, '0'))
                .join('');
        }

        /**
         * converts hexText to ArrayBuffer
         * @param {string} hexText - hexadecimal text to convert to an array buffer
         * @returns {ArrayBuffer}
         */
        function convertHexToBuffer(hexText) {
            assertString(hexText);
            assertStringRange(hexText, "0123456789abcdef");

            if ((hexText.length % 2) !== 0) {
                throw new RangeError('hexText must be an even number of characters');
            }

            const view = new Uint8Array(hexText.length / 2)

            let index = 0;
            for (let i = 0; i < hexText.length; i += 2) {
                // next pair of hex characters
                // two hex characters, 8 bits
                const pair = hexText.substring(i, i + 2);
                const bits = parseInt(pair, 16);

                // insert bits into the buffer at the next position
                view[index] = bits
                index++;
            }

            const buffer = view.buffer;

            return buffer;
        }

        /**
         * converts text to gzip compressed hexText
         * @param {string} text - a string
         * @returns {Promise<string>} gzip compressed hexText
         */
        async function compress(text) {
            // https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream

            const readStream = new Response(text);
            const compressedReadableStream = readStream.body.pipeThrough(new CompressionStream('gzip'));
            const response = new Response(compressedReadableStream);

            const buffer = await response.arrayBuffer();
            const compressedHexText = convertBufferToHex(buffer);
            return compressedHexText;
        }

        /**
         * converts gzip compressed hexText to text
         * @param {string} compressedHexText - gzip compressed hexText
         * @returns {string} text
         */
        async function decompress(compressedHexText) {

            const buffer = convertHexToBuffer(compressedHexText);

            const readStream = new Response(buffer);
            const decompressedReadableStream = readStream.body.pipeThrough(new DecompressionStream('gzip'))
            const response = new Response(decompressedReadableStream);

            const text = await response.text();

            return text;
        }

        /**
         * text compress decompress
         */
        async function testHexText() {
            // input text
            const configuration = getConfigurationSnapshot();
            const snapshotText = getConfigurationToTextJson(configuration);
            console.log(snapshotText);

            const compressedText = await compress(snapshotJsonText);
            console.log(compressedText);

            const decompressedText = await decompress(compressedText);
            console.log(decompressedText);

            // should be able to decompress
            const equal = snapshotJsonText === decompressedText
            console.log(equal);

            if (!equal) {
                throw new Error("compress does not decompress");
            }
        }

        //#endregion "hextext"

        /**
         * convert configuration to json text
         * @param {Configuration} configuration
         * @returns {string}
         */
        function getConfigurationToTextJson(configuration, { pretty } = { pretty: false }) {
            // pretty option adds spaces for readability
            const text = pretty ? JSON.stringify(configuration, undefined, "    ") : JSON.stringify(configuration);
            return text;
        }

        /**
         * get a configuration from json text
         * @param {string} text
         * @returns {Configuration}
         */
        function getConfigurationFromTextJson(text) {
            const configuration = JSON.parse(text);
            return configuration;
        }

        /**
         * get a configuration from hex text (compressed json text)
         * @param {string} text - hex text
         * @returns {Promise<Configuration>}
         */
        async function getConfigurationFromTextHex(text) {
            const decompressedText = await decompress(text);
            const configuration = getConfigurationFromTextJson(decompressedText);
            return configuration;
        }

        /**
         * get a configuration from markdown text
         * @param {string} text - hex text
         * @returns {Configuration}
         */
        function getConfigurationFromTextMarkdown(text) {
            const configuration = parseMarkdownToConfiguration(text);
            console.log(configuration);
            return configuration;
        }

        /**
         * pull out configuration stored in the svg
         * get a configuration from desc element containing configuration hex tex embedded in svg text
         * @param {string} text - svg text
         * @returns {Configuration}
         */
        async function getConfigurationFromSvg(text) {

            // pull out configuration hex text from configuration desc element
            const parser = new DOMParser();
            const svg = parser.parseFromString(text, "image/svg+xml");

            // note: The configuration is the inner html of the first element with the id 'configuration' 
            /**
             * @type {SVGDescElement}
             */
            const configurationDesc = svg.getElementById("configuration");
            const configurationTextHex = configurationDesc.innerHTML; // note: no innerText element in SVGDescElement

            const configuration = await getConfigurationFromTextHex(configurationTextHex);
            return configuration;
        }

        /**
         * @param {string} name - name of the file
         * @param {string} text - file text
         * @returns {Configuration}
         */
        async function getConfigurationFromFile(name, text) {
            let configuration = undefined;

            // load differently based on the file extension
            const nameLowercase = name.toLowerCase();

            if (nameLowercase.endsWith(".json")) {
                configuration = getConfigurationFromTextJson(text);
            } else if (nameLowercase.endsWith(".md")) {
                configuration = getConfigurationFromTextMarkdown(text);
            } else if (nameLowercase.endsWith(".txt")) {
                configuration = await getConfigurationFromTextHex(text);
            } else if (nameLowercase.endsWith(".svg")) {
                configuration = getConfigurationFromSvg(text);
            }

            return configuration;
        }

        /**
         * download a file by inserting a link element with the url containing the encoding
         * @param {Object} o
         * @param {string} o.filename
         * @param {string} o.url
         */
        function downloadFileUrl({ filename, url }) {
            const element = document.createElement('a');

            element.setAttribute('href', url);
            element.setAttribute('download', filename);
            element.click();
        }

        /**
         * download file
         * @param {Object} o
         * @param {string} o.filename - name of the file to download
         * @param {string} o.text - contents of the text file utf-16 text
         * @param {string} o.encoding - mime type of the file
         */
        function downloadFile({ filename, text, encoding }) {
            const blob = new Blob([text], { type: encoding })
            const downloadUrl = URL.createObjectURL(blob);
            //console.log(downloadUrl)
            downloadFileUrl({ filename, url: downloadUrl });
            URL.revokeObjectURL(downloadUrl);

            // legacy
            // const component = encodeURIComponent(text);
            // const url = `${encoding};charset=utf-16, ` + component;
            // downloadFileUrl({filename, url})
        }

        /**
         * @param {FileList} files
         */
        async function buttonLoadSnapshotFromFile(files) {
            if (files.length !== 1) {
                console.error(`can only load a single file`);
                return;
            }

            const file = files[0];
            const name = file.name;
            const text = await file.text();

            const configuration = await getConfigurationFromFile(name, text);

            if (configuration === undefined) {
                console.error(`unable to load file extension ${name}`);
            } else {
                loadConfiguration(configuration);
            }
        }



        /**
         * converts a configuration to hex text
         * @param {Configuration} configuration
         * @returns {Promise<string>} hex text
         */
        async function getConfigurationToTextHex(configuration) {
            const snapshotJsonText = getConfigurationToTextJson(configuration);
            //console.log(snapshotJsonText);

            const compressedText = await compress(snapshotJsonText);
            //console.log(compressedText);
            return compressedText;
        }



        /**
         * @param {Configuration} configuration
         */
        function saveConfigurationImageCanvas(configuration) {

            // for testing purposes allow preview of the canvas
            const div = document.getElementById("div_configuration_canvas");
            // reset
            div.innerText = "";
            div.appendChild(canvas);
        }

        //#region "svg"

        /**
         * @param {string} text - text for the desc element
         * @param id {string} - id for the desc element for easy access
         */
        function createSvgDescElement(text, id) {
            const descElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'desc'
            );

            descElement.setAttribute("id", id);

            const textNode = document.createTextNode(text);
            descElement.appendChild(textNode);

            return descElement;
        }

        /**
         * @param {number} x - x of lower left corner
         * @param {number} y - y of lower left corner
         * @param {string} text - the text to write
         * @param {string|undefined} tooltip - 
         * @returns {SVGTextElement}
         */
        function createSvgTextElement(x, y, text, tooltip) {
            const textElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'text'
            );

            textElement.setAttribute("x", x);
            textElement.setAttribute("y", y);

            textElement.setAttribute("alignment-baseline", "baseline");

            // TODO: sanitize the text
            const textNode = document.createTextNode(text);
            textElement.appendChild(textNode);

            if (typeof tooltip === "string") {
                const titleElement = createSvgTitleElement(tooltip);
                textElement.append(titleElement);
            }

            return textElement;

        }

        /**
         * @param {number} x - x of upper left corner
         * @param {number} y - y of upper left corner
         * @param {number} size - width and height of the square
         * @param {color} string - fill color
         * 
         * @returns {SVGRectElement}
         */
        function createSvgSquareElement(x, y, size, color) {

            const rectElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'rect'
            );

            rectElement.setAttribute("x", x);
            rectElement.setAttribute("y", y);

            rectElement.setAttribute("width", size);
            rectElement.setAttribute("height", size);

            rectElement.setAttribute("style", `fill:${color};stroke:black;`);

            return rectElement;
        }

        /**
         * @param {string} title - title text
         * @returns {SVGTitleElement}
         */
        function createSvgTitleElement(title) {
            const titleElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'title'
            );

            const textElement = document.createTextNode(title);
            titleElement.append(textElement);

            return titleElement;
        }

        /**
         * @param {number} x - x of upper left corner
         * @param {number} y - y of upper left corner
         * @param {number} size - diameter of the circle
         * 
         * @param {string} color - fill color
         * @param {strokeWidth} number - width of surrounding stroke
         * 
         * @param {string} tooltip - tooltip to show
         * 
         * @returns {SVGRectElement}
         */
        function createSvgCircleElement(x, y, size, color, strokeWidth, tooltip) {
            const circleElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'circle'
            );

            const radius = size / 2
            const dx = radius;
            const dy = radius;

            circleElement.setAttribute("cx", x + dx);
            circleElement.setAttribute("cy", y + dy);

            circleElement.setAttribute("r", radius);

            circleElement.setAttribute("style", `fill:${color};stroke:black;stroke-width:${strokeWidth};`);

            if (typeof tooltip === "string") {
                const titleElement = createSvgTitleElement(tooltip);
                circleElement.append(titleElement);
            }

            return circleElement;
        }

        /**
         * @param {number} x - x of upper left corner
         * @param {number} y - y of upper left corner
         * @param {string} id - id of the element
         * @param {string} title - title for the element
         * @param {number} elementSize - width and height of the checkbox
         * @param {boolean|undefined} checked - is the checkbox checked
         * @param {string|undefined} tooltip - 
         * @param {ConfigurationConfigCheckbox} config - 
         * 
         * @returns {SVGGroupElement}
         */
        function createSvgCheckboxGroupElement(x, y, id, title, elementSize, checked, tooltip, config) {
            const gElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'g'
            );

            gElement.setAttribute("id", id);

            // checkbox
            // rectangle draws down from the top left x, y
            // use config color for checkbox or default color
            const color = checked ? config?.checked?.color || "black" : config?.unchecked?.color || "white";
            const checkboxElement = createSvgSquareElement(x, y, elementSize, color);
            gElement.appendChild(checkboxElement);

            // text
            // text draws from the left bottom x y
            const dx = elementSize + 10;
            const dy = elementSize;
            const textElement = createSvgTextElement(x + dx, y + dy, title, tooltip);
            gElement.appendChild(textElement);

            return gElement;
        }

        /**
         * @param {number} x - x of upper left corner
         * @param {number} y - y of upper left corner
         * @param {string} id - id of the element
         * @param {string} title - title for the element
         * @param {number} elementSize - size of the element
         * @param {string|undefined} selection - likert selection
         * @param {string|undefined} tooltip - 
         * @param {ConfigurationConfigLikert} config -
         * @param {} 
         */
        function createSvgLikertGroupElement(x, y, id, title, elementSize, selection, tooltip, config) {
            // group likert circles
            const gElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'g'
            );

            gElement.setAttribute("id", id);

            const spacing = 10;

            const getDx = (index) => (elementSize + spacing) * index

            const options = config.options.map(({ value, description, color }, index) => {

                // offset between elements
                const dx = getDx(index);

                // differentiate selected via strokeWidth
                const tooltip = value; // currently used as the selection
                const strokeWidth = tooltip === selection ? 3 : 1;

                const optionElement = createSvgCircleElement(x + dx, y, elementSize, color, strokeWidth, tooltip);

                return optionElement;

            });


            gElement.append(...options);

            // text
            // text draws from the left bottom x y
            const dx = getDx(options.length - 1) + elementSize + 10;//10 + 10;
            const dy = elementSize;
            const textElement = createSvgTextElement(x + dx, y + dy, title, tooltip);
            gElement.appendChild(textElement);

            return gElement;

        }

        // sweet sweet SVGs! Pixel perfection!
        /**
         * @param {Configuration} configuration
         * @returns {Promise<SVGSVGElement>}
         */
        async function getConfigurationToSvgElement(configuration) {
            const { title, description, items, state, configs } = configuration;

            const configDefault = configs["default"];
            //console.log(configDefault);

            const scale = 1;

            // size of squares and circles
            const elementSize = 10 * scale;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');


            // append text hex description of the configuration that generated the svg
            const configurationTextHex = await getConfigurationToTextHex(configuration);
            svg.appendChild(createSvgDescElement(configurationTextHex, "configuration"));


            const height = elementSize + 10// need to measure height of text
            let y = height;
            let x = 0;

            // title
            svg.appendChild(createSvgTextElement(x, y, title));

            // spacing between elements
            const spacing = height + 10 * scale / 2;
            y = spacing;
            x = 10;


            // need 10 elements for current likert, would really need to calculate
            // 200 is room for text
            const gridX = elementSize * 10 + (200 * scale);

            // elements
            const gridY = spacing * (items.length + 1);

            //svg.setAttribute("style", "background-color:teal");
            // TODO: set this to calculated minimum pixel width and height
            //svg.setAttribute("viewbox", `0 0 ${gridX} ${gridY}`);
            svg.setAttribute("width", gridX); //"100%");
            svg.setAttribute("height", gridY);
            // TODO: scale text

            items.forEach(({ id, title, input, description }) => {
                // draw each separate input
                if (input === "checkbox") {
                    const value = state === undefined ? undefined : state[id]?.checkbox;
                    const config = configDefault?.checkbox;

                    const checkboxGroup = createSvgCheckboxGroupElement(x, y, id, title, elementSize, value, description, config);
                    svg.append(checkboxGroup);

                } else if (input === "likert") {
                    const value = state === undefined ? undefined : state[id]?.likert;
                    const config = configDefault?.likert;

                    const likertGroup = createSvgLikertGroupElement(x, y, id, title, elementSize, value, description, config);
                    svg.append(likertGroup);
                }

                // increase offset
                y += spacing;
            });


            return svg;

        }

        //#endregion "svg"

        //#region "svg interaction"

        // can get the target which could have the target and the id
        function onclickSvg(e) {
            //console.log("clicked SVG")
            const target = e?.target;
            /**
             * @type HTMLElement
             */
            const parentElement = target?.parentElement;

            const nodeName = parentElement?.nodeName;
            const id = parentElement?.id;

            // update the state

            const configuration = getConfigurationSnapshot();
            const value = configuration?.state[id];
            if (value) {
                const { checkbox, likert } = value;

                const isCheckbox = Object.prototype.hasOwnProperty.call(value, "checkbox");
                const isLikert = Object.prototype.hasOwnProperty.call(value, "likert");

                if ([isCheckbox, isLikert].filter(x => x).length > 1) {
                    console.error(`${id} has multiple values defined`);
                }

                if (isCheckbox) {
                    //console.log(`clicked checkbox ${id}`);
                    configuration.state[id].checkbox = !checkbox;
                }

                if (isLikert) {
                    //console.log(`clicked likert ${id}`);
                    // will need to change if there is a new way of storing the text
                    const title = target.firstChild.firstChild.data;
                    // allow de-selection
                    const current = configuration.state[id].likert;

                    configuration.state[id].likert = current === title ? null : title;
                }

                //console.log(configuration.state)
                loadConfiguration(configuration);
            }
        }

        /**
         * draws the configuration as an interactive svg on the page
         */
        async function drawConfigurationImage() {
            const configuration = getConfigurationSnapshot()

            // draw the configuration as an svg
            const svg = await getConfigurationToSvgElement(configuration);

            // set the contents of the div element
            const div = document.getElementById("div_configuration_svg");

            // reset
            div.innerText = "";
            div.appendChild(svg);
        }

        //#endregion "svg interaction"

        /**
         * get the support level for required APIs
         */
        function getBrowserSupport() {
            // Required APIs to work.
            // list all APIs
            // https://developer.mozilla.org/en-US/docs/Web/API/Compression_Streams_API
            const supportsCompressionStream = "undefined" !== typeof CompressionStream;
            // https://developer.mozilla.org/en-US/docs/Web/API/DecompressionStream
            const supportsDecompressionStream = "undefined" !== typeof DecompressionStream;

            /**
             * @type {[string, boolean][]}
             */
            const apis = [
                ["CompressionStream", supportsCompressionStream],
                ["DecompressionStream", supportsDecompressionStream],
            ];
            const supported = apis.every(([_, supports]) => supports);

            return {
                apis,
                supported,
            }
        }

        //
        // UI callable methods
        //

        //#region "interactions"
        /**
         * browser details
         * writes if the browser is supported
         * @param {Object} [options=undefined]
         * @param {boolean} [options.showDetails=undefined] - show additional details about the browser
         */
        function displayBrowserSupport(options) {
            const div = document.getElementById("div_browser_info");

            const { apis, supported } = getBrowserSupport();

            if (!supported) {
                document.getElementById("p_browser_not_supported_message").hidden = false;
            }

            const showDetails = typeof options !== "undefined" && options.showDetails;

            // show details about supported APIs
            if (showDetails) {
                // user Agent
                const agent = window.navigator.userAgent;
                const infoAgent = document.createElement("p");
                infoAgent.appendChild(document.createTextNode(agent));
                div.appendChild(infoAgent);

                // APIs
                div.appendChild(document.createTextNode("Required API: supported"))

                apis.forEach(([name, supports]) => {
                    const infoApi = document.createElement("p");
                    const br = document.createElement("br");
                    div.appendChild(br);
                    div.appendChild(document.createTextNode(`${name}: ${supports}`));
                });
            }
        }
        //#endregion "interactions"

        function getUrlHash() {
            const text = window.location.hash.substring(1);
            return text
        }


        //#region "buttons"
        /**
         * button
         * 
         * Loads snapshot configuration in URL hash
         * If no url hash, loads default configuration.
         */
        async function buttonLoadSnapshotFromUrlHash() {
            // # comes after the url
            // remove #
            const text = getUrlHash();
            let configuration;

            if (text) {
                const configuration = await getConfigurationFromTextHex(text);
                loadConfiguration(configuration);
            } else {
                console.log("no url hash to load - load default");
                const configuration = getDefaultConfiguration();
                loadConfiguration(configuration);
            }
        }

        async function getSnapshotTextHex() {
            const configuration = getConfigurationSnapshot();
            const text = await getConfigurationToTextHex(configuration);
            return text;
        }

        function getSnapshotMarkdown() {
            const configuration = getConfigurationSnapshot();
            const text = getConfigurationToMarkdown(configuration);
            return text;
        }

        async function saveSnapshotToUrlHash() {
            const text = await getSnapshotTextHex();

            // set to hash at top of window
            window.location.hash = text;
        }

        /**
         * button
         */
        function buttonClearUrlHash() {
            window.history.replaceState(null, '', window.location.pathname);
        }

        /**
         * button 
         */
        async function buttonSaveSnapshotToUrlHash() {
            await saveSnapshotToUrlHash();
        }

        /**
         * button
         * 
         * Write URL to Clipboard so it can be shared.
         */
        async function buttonShareUrlToClipboard() {
            const text = await getSnapshotTextHex();
            const baseUrl = window.location.href.replace(window.location.hash, "");
            const url = baseUrl + '#' + text;
            navigator.clipboard.writeText(url);
        }

        /**
         * button 
         * get snapshot of the current configurations answers and save to JSON
         */
        async function buttonSaveSnapshotToFileMarkdown() {
            const configuration = getConfigurationSnapshot();

            const filename = `${configuration.title}.md`;
            const text = getConfigurationToMarkdown(configuration);
            const encoding = 'data:text/plain';
            downloadFile({ filename, text, encoding });
        }

        /**
         * button 
         * get snapshot of the current configurations answers and save to JSON
         */
        async function buttonSaveSnapshotToFileJson() {
            const configuration = getConfigurationSnapshot();

            const filename = `${configuration.title}.json`;
            const text = getConfigurationToTextJson(configuration, { pretty: true });
            const encoding = 'data:text/plain';
            downloadFile({ filename, text, encoding });
        }

        /**
         * button 
         * get snapshot of the current configurations answers and save to svg
         */
        async function buttonSaveSnapshotToFileSvg() {
            const configuration = getConfigurationSnapshot();

            const svg = await getConfigurationToSvgElement(configuration);
            var serializer = new XMLSerializer();
            var snapshotSvgText = serializer.serializeToString(svg);

            const filename = `${configuration.title}.svg`;
            const text = snapshotSvgText;
            const encoding = 'data:image/svg+xml';
            downloadFile({ filename, text, encoding });
        }

        /**
         * button 
         * get snapshot of the current configurations answers and save to svg
         */
        async function buttonSaveSnapshotToFileTextHex() {
            const configuration = getConfigurationSnapshot();

            const filename = `${configuration.title}.txt`;
            const text = await getConfigurationToTextHex(configuration);
            const encoding = 'data:text/plain';
            downloadFile({ filename, text, encoding });
        }

        /**
         * Currently Open Edit Type
         * @type {"markdown" | "json" | undefined}
         */
        let gOpenEditType = undefined;

        /**
         * Open edit screen
         * @param {"json" |"markdown"} type
         */
        function editOpen(type) {
            const div = document.getElementById("div_edit");
            const textarea = document.getElementById("textarea_edit");

            gOpenEditType = type;

            /**
             * @type {string}
             */
            let value;

            // markdown
            if (type === "markdown") {
                value = getSnapshotMarkdown();
            }

            // json
            if (type === "json") {
                value = getConfigurationToTextJson(getConfigurationSnapshot(), { pretty: true });
            }

            // set text area value to current configuration json
            textarea.value = value;

            // show edit screen
            div.hidden = false;
        }

        /**
         * close edit screen
         */
        function editClose() {
            const div = document.getElementById("div_edit");
            const textarea = document.getElementById("textarea_edit");

            // hide edit screen and reset value
            div.hidden = true;
            textarea.value = "";
        }

        /**
         * button
         * Open edit screen
         */
        function buttonEditMarkdown() {
            editOpen("markdown");
        }

        /**
         * button
         * Open edit screen
         */
        function buttonEditJson() {
            editOpen("json");
        }

        /**
         * button
         * Save edit configuration
         */
        function buttonEditSave() {
            const textarea = document.getElementById("textarea_edit");
            const value = textarea.value;

            /**
             * @type {Configuration}
             */
            let configuration;

            // markdown
            if (gOpenEditType === "markdown") {
                configuration = getConfigurationFromTextMarkdown(value);
            }

            // json
            if (gOpenEditType === "json") {
                configuration = JSON.parse(textarea.value);
            }

            // load modified configuration
            loadConfiguration(configuration);

            editClose();
        }

        /**
         * button
         * discard change and close
         */
        function buttonEditCancel() {
            editClose();
        }

        //#endregion "buttons"

        /**
         * called when the configuration changes
         */
        function onConfigurationUpdated() {
            // update images
            drawConfigurationImage()

            // update hash
            // useful if always want a shareable url
            //saveSnapshotToUrlHash();
        }

        /**
         * sets icon svg as the Favicon data url
         */
        function setIconAsFavicon() {
            const icon = document.getElementById("icon")
            const data = (new XMLSerializer()).serializeToString(icon);
            const dataUrl = "data:image/svg+xml," + data;

            document.getElementById("icon").setAttribute("href", dataUrl);
        }

        /**
         * Default configuration when there is none present
         * Parses from the default Markdown configuration
         */
        function getDefaultConfiguration() {
            const configuration = getConfigurationFromTextMarkdown(defaultConfigurationMarkdown);
            return configuration;
        }



        /**
         * Only function run on start
         * Set up everything, link all UI elements
         */
        async function initialize() {
            // check if the browser is supported
            const { supported } = getBrowserSupport();
            if (!supported) {
                document.getElementById("div_controls").innerText = "";
                displayBrowserSupport({ showDetails: true });
                // don't set up any of the handlers
                return;
            }

            setIconAsFavicon();

            // Initial configuration
            // pull from url has if available or load default
            const urlHash = getUrlHash();
            console.log(urlHash);
            /**
             * @type {Configuration}
             */
            let configuration = undefined;
            if (urlHash.length === 0) {
                // use default MD configuration
                configuration = getDefaultConfiguration();
            } else {
                configuration = await getConfigurationFromTextHex(urlHash);
            }
            loadConfiguration(configuration);

            // Start - Test
            // Test Code to run at start

            // End - Test

            drawConfigurationImage()

            // update
            document.getElementById("div_configuration_svg").onclick = onclickSvg;

            // Edit
            document.getElementById("button_edit_markdown").onclick = buttonEditMarkdown;
            document.getElementById("button_edit_json").onclick = buttonEditJson;
            document.getElementById("button_edit_save").onclick = buttonEditSave;
            document.getElementById("button_edit_cancel").onclick = buttonEditCancel;

            // Url Hash
            document.getElementById("button_save_url").onclick = buttonSaveSnapshotToUrlHash;
            document.getElementById("button_load_url").onclick = buttonLoadSnapshotFromUrlHash;
            document.getElementById("button_clear_url").onclick = buttonClearUrlHash;
            document.getElementById("button_share_url").onclick = buttonShareUrlToClipboard;

            // File
            document.getElementById("button_save_file_markdown").onclick = buttonSaveSnapshotToFileMarkdown;
            document.getElementById("button_save_file_json").onclick = buttonSaveSnapshotToFileJson;
            document.getElementById("button_save_file_text").onclick = buttonSaveSnapshotToFileTextHex;
            document.getElementById("button_save_file_svg").onclick = buttonSaveSnapshotToFileSvg;

            // Load file
            /**
             * @type {HTMLInputElement}
             */
            const input_file = document.getElementById("input_load_file");
            input_file.onchange = async () => {
                const files = input_file.files;
                await buttonLoadSnapshotFromFile(files);
            };


            // Test - Start
            // Test Code to run at end

            // open edit view
            //document.getElementById("button_edit").click();

            // download markdown
            //document.getElementById("button_save_file_markdown").click();

            // Test - End
        }

        initialize();





    </script>
</body>

</html>