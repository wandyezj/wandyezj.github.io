<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Checklist</title>
</head>

<body>

    <!--
        Generate a configurable list layout with clickable boxes and allow export to an image

        Allow export and sharing via URL

        Pieces:

        Configuration
            - The `configuration` is the set, layout, and state of possible items.     
            - fixed set of item options
                - checkbox
                - likert - future
            - hostable and pointable on any URL
                - determine which parser to use based off .md or .json suffix

        load only
            - markdown template (more easily viewable and editable than json)

        save / load
            - json configuration (allows saving to local file system)
            - compressed hex url hash (allows sharing link)
            - TODO: image (render selection for reference and share, and load from image via embedded state)

        HTML Render and Selection

        Everything loaded is a configuration
            - markdown configuration is a template
            - json or URL configurations include answers

        edit
            - probably want a way to edit inline

        Canvas Draw and Image Export / Download
            - possible via screen capture?
            - steganography embedd compressed information into the image since programs remove metadata, also embedd the metadata
            - RGBA can tack on at the end, but still need the total length of data to read

        Styling
            - will need to style so it looks appealing

        Principles:
            - hostable anywhere - self contained HTML page
            - sharable and private
                - no telemetry
                - no storage or persistance of data outside of users machine
            - configurable and customizable, with sharable configurations
            - machine parsable if shared
            - secure
                - do not want to allow links that people can click, except to know safe domains (maybe wikipedia links are ok?)
                - defend against HTML injection from input sources
            - compatible this means old configurations and renders continue to work
                - can be done by versioning, point to specific HTML page
                - or keep everything backwards compatible and have shim layers that translate to new logic based on an embedded version number
    
        Reference
        https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input/checkbox
        https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file
        https://developer.mozilla.org/en-US/docs/Web/API/File

        https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
    
            -->
    <button id="button_save_url">Save URL</button>
    <br>
    <button id="button_load_url">Load URL</button>
    <br>
    <br>

    <label for="input_load_file">Load json or md configuration</label>
    <input id="input_load_file" type="file" accept=".json,.md">

    <button id="button_save_file">Save JSON</button>
    <br>

    <button id="button_save_image">Save Image</button>
    <br>

    <!-- Configuration Placeholder with actual actions -->

    <div id="div_configuration">

    </div>

    <br>
    <!-- Div to contain the canvas for the image, shown for testing purposes -->
    <div id="div_configuration_canvas">

    </div>

    <script>


        // Example actually use markdown as all input
        const defaultConfigurationJson = {
            title: "example configuration title",
            description: "example configuration description",

            // All independent items
            items: [
                // items and order they appear in
                {
                    // id is derivable from title in md but must be specified in json
                    id: "example_checkbox_item_title",
                    title: "example checkbox item title",
                    description: "example checkbox item description",
                    input: "checkbox"
                }
            ],

            // layout
            // probably want a separate layout section that can determine how items are layed out
            // maybe sections and subsections with their own titles and descriptions
            // should these sections be infinitely nestable?
            // do section titles become part of the item id? Probably yes when layed out with markdown

            // state of all items
            // id -> value
            // id should be present in the items
            // value is dependent on the item type
            // empty assumes default value
            state: {
                // by default empty
            }

        }

        // whitespace matters
        const defaultConfigurationMarkdown = `
# example title
> example description

- [ ] example item
    > example item description
- [ ] example item 2
    > example item description

`;

        /**
         * create json configuration from a markdown description
         */
        function parseMarkdownToConfiguration(markdownInput) {
            const markdown = markdownInput.trim()

            const lines = markdown.split("\n");
            // Could scrub empty lines for utility, but then need a mapping of lines to orignal line numbers for errors

            /**
             * Title for the whole list
             */
            let listTitle = undefined;

            /**
             * description for the whole list
             */
            let listDescription = undefined;

            /**
             * items in the list
             * Each item has
             * - title
             * - description
             * - input- the type of input 
             */
            const listItems = [];


            // Delimiters
            const delimiterListTitle = "# ";
            const delimiterListDescription = "> ";
            const delimiterListItemCheckbox = "- [ ] ";
            const delimiterListItemDescription = "    > ";

            for (let i = 0; i < lines.length; i++) {
                // Get all lines before and after
                const linePrevious = i > 0 ? lines[i - 1] : undefined;
                const line = lines[i];
                const lineNext = i + 1 < lines.length ? lines[i + 1] : undefined;
                //console.log(line);

                // parse the line
                if (line.startsWith(delimiterListTitle)) {
                    // List Title
                    if (listTitle === undefined) {
                        listTitle = line.substring(delimiterListTitle.length).trim();
                    } else {
                        console.error(`line [${i}]: duplicate list title - only a single list title may be defined`);
                    }

                    // List Description
                    // Must be next line after title
                    if (lineNext !== undefined && lineNext.startsWith(delimiterListDescription)) {
                        listDescription = lineNext.substring(delimiterListDescription.length).trim();
                        // already parsed line go to next
                        i++;
                    }

                } else if (line.startsWith(delimiterListItemCheckbox)) {
                    // List Item Checkbox

                    const itemTitle = line.substring(delimiterListItemCheckbox.length).trim();
                    const itemInput = "checkbox";
                    let itemDescription = undefined;

                    if (lineNext !== undefined && lineNext.startsWith(delimiterListItemDescription)) {
                        // List Item Description
                        itemDescription = lineNext.substring(delimiterListItemDescription.length).trim();

                        // Already parsed the line go to next
                        i++;
                    }

                    // mapping is imperfect since it filters characters
                    const itemBaseId = titleToId(itemTitle);
                    let itemId = itemBaseId;

                    // id must not already be present
                    // if id is already present attach a numeric count to the end to make it unique
                    let itemIdCount = 0;
                    while (-1 !== listItems.findIndex(({ id }) => id === itemId)) {
                        itemIdCount++;
                        itemId = itemBaseId + "_" + itemIdCount;
                    }


                    listItems.push({
                        id: itemId,
                        title: itemTitle,
                        description: itemDescription,
                        input: itemInput,
                    });

                } else {
                    // Unknown What is this?
                    if (line !== "") {
                        console.error(`line [${i}]: unknown value [${line}]`);
                    }
                }
            }

            // Assemble configuration Json
            const configurationJson = {
                title: listTitle,
                description: listDescription,
                items: listItems,
            }

            return configurationJson;
        }

        /**
         * Map item title to id
         * id can only consist of lowercase letters, numbers, and underscores
         * converts uppercase to lowercase
         * removes duplicate spaces and replaces the space with an underscore
         */
        function titleToId(title) {
            const characters = Array.from(title.toLowerCase());

            // characters allowed in an identifier
            const alphabet = "abcdefghijklmnopqrstuvwxyz";
            const numbers = "0123456789"
            const space = " "

            const valid = alphabet + numbers + space;

            const validCharacters = Array.from(valid);

            // filter out invalid characters, remove duplicate spaces, map spaces to underscores
            const idArray = characters
                .filter((c) => validCharacters.includes(c))
                .filter((c, index, array) =>
                    // no duplicate spaces
                    c !== space || (c === space && index - 1 >= 0 && array[index - 1] !== space)
                ).map((c) => c === space ? "_" : c);

            const id = idArray.join("");
            return id;
        }

        /**
         * load the configuration to html on the pace so it can be manipulated
         * include state informtion
         */
        function loadConfiguration(configuration) {

            const div = document.getElementById("div_configuration");
            // reset everything in the div, (otherwise end up with duplicate elements on subsequent loads)
            div.innerText = "";

            const { title, description, items, state } = configuration;

            const defaultTitle = "List";
            const defaultDescription = "";

            const listTitle = title || defaultTitle;

            const elementListTitle = document.createElement("h1");
            elementListTitle.innerText = listTitle;

            const elementListDescription = document.createElement("p");
            elementListDescription.innerText = description || defaultDescription;

            document.title = listTitle;

            div.appendChild(elementListTitle);
            div.appendChild(elementListDescription);

            // append all list elements
            const children = items.map(({ id, title, description, input }) => {

                const elementDiv = document.createElement("div");

                // determine input type
                // why not aimply assign? - security plus elements have different needs
                if (input === "checkbox") {
                    const elementInput = document.createElement("input");
                    elementInput.type = "checkbox";
                    elementInput.name = title;
                    elementInput.id = id;

                    // use preserved state
                    if (state && state[id] && typeof state[id] === "boolean") {
                        elementInput.checked = state[id]
                    }

                    const elementLabel = document.createElement("label");
                    elementLabel.for = id;
                    elementLabel.innerText = title;

                    elementDiv.appendChild(elementInput);
                    elementDiv.appendChild(elementLabel);

                } else {
                    console.error(`invalid type for item [${input}]`);
                    const p = document.createElement("p");
                    p.innerText = `item [${name}] invalid type [${input}] for item`;
                    elementDiv.appendChild(p);
                }

                return elementDiv;

            });

            div.append(...children);

        }


        /**
         * Get a snapshot of the current configuration
         * a snapshot is simply a configuration with state
         */
        function getConfigurationSnapshotJson(configuration) {
            // clone configuration
            const snapshot = JSON.parse(JSON.stringify(configuration));

            // empty state
            snapshot["state"] = {};

            // retrieve current state and bind it to the snapshot
            snapshot.items.forEach(({ id, input }) => {
                const element = document.getElementById(id);
                if (element) {
                    if (input === "checkbox") {
                        const checked = element.checked;
                        snapshot.state[id] = checked;
                    }
                }
            });

            return snapshot
        }

        function getConfigurationSnapshotJsonText(configuration) {
            const snapshotJson = getConfigurationSnapshotJson(configuration);
            const snapshotText = JSON.stringify(snapshotJson);
            return snapshotText;
        }

        //
        // UI callable methods
        //

        /**
         * button 
         * get snapshot of the current configurations answers and save to JSON
         */
        function saveSnapshotJsonTextFile() {
            const snapshot = getConfigurationSnapshotJson(gconfiguration);
            const snapshotJsonText = JSON.stringify(snapshot, undefined, "    ");
            console.log(snapshotJsonText);
            const filename = `${snapshot.title}.json`;
            downloadTextFile(filename, snapshotJsonText);
        }

        /**
         * download file
         * @param filename - name of the file to download
         * @param text - contents of the text file
         */
        function downloadTextFile(filename, text) {
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8, ' + encodeURIComponent(text));
            element.setAttribute('download', filename);
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        /**
         * loads up the configuration from json text
         */
        function loadConfigurationTextJson(text) {
            const configuration = JSON.parse(text);
            loadConfiguration(configuration);
            gconfiguration = configuration;
        }

        /**
         * loads up the configuration from markdown text
         */
        function loadConfigurationTextMarkdown(text) {
            const configuration = parseMarkdownToConfiguration(text);
            console.log(configuration);
            loadConfiguration(configuration);
            gconfiguration = configuration;
        }

        async function loadConfigurationFile(files) {
            if (files.length !== 1) {
                console.error(`can only load a single file`);
                return;
            }

            const file = files[0];
            const name = file.name;
            const text = await file.text();

            // load differently based on the file extension
            const nameLowercase = name.toLowerCase();
            if (nameLowercase.endsWith(".json")) {
                loadConfigurationTextJson(text);
            } else if (nameLowercase.endsWith(".md")) {
                loadConfigurationTextMarkdown(text);
            } else {
                console.error(`unknown how to load file extension ${name}`);
            }
        }

        function assertString(variable) {
            if (typeof variable !== 'string') {
                throw new TypeError('variable must be a string')
            }
        }

        /**
         * check that string is only made up of valid characters
         * @param check - string to check
         * @param valid - string of valid characters
         */
        function assertStringRange(check, valid) {
            assertString(check);
            assertString(valid);

            const validCharacters = Array.from(valid);

            // filter out invalid characters, remove duplicate spaces, map spaces to underscores
            const invalid = Array.from(check).filter((c) => !validCharacters.includes(c));
            if (invalid.length > 0) {
                throw new RangeError(`Invalid characters in string: [${invalid.join("")}]`);
            }
        }

        /**
         * converts an ArrayBuffer to hexText
         * @param buffer - ArrayBuffer
         */
        function convertBufferToHex(buffer) {
            // https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
            return [...new Uint8Array(buffer)]
                .map(x => x.toString(16).padStart(2, '0'))
                .join('');
        }

        /**
         * converts hexText to ArrayBuffer
         */
        function convertHexToBuffer(hexText) {
            assertString(hexText);
            assertStringRange(hexText, "0123456789abcdef");

            if ((hexText.length % 2) !== 0) {
                throw new RangeError('hexText must be an even number of characters');
            }

            const view = new Uint8Array(hexText.length / 2)

            let index = 0;
            for (let i = 0; i < hexText.length; i += 2) {
                // next pair of hex characters
                // two hex characters, 8 bits
                const pair = hexText.substring(i, i + 2);
                const bits = parseInt(pair, 16);

                // insert bits into the buffer at the next position
                view[index] = bits
                index++;
            }

            const buffer = view.buffer;

            return buffer;
        }

        /**
         * converts text to gzip compressed hexText
         * @param text - a string
         * @returns gzip compressed hexText
         */
        async function compress(text) {
            // https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream

            const readStream = new Response(text);
            const compressedReadableStream = readStream.body.pipeThrough(new CompressionStream('gzip'));
            const response = new Response(compressedReadableStream);

            const buffer = await response.arrayBuffer();
            const compressedHexText = convertBufferToHex(buffer);
            return compressedHexText;
        }

        /**
         * converts gzip compressed hexText to text
         * @param compressedHexText - gzip compressed hexText
         * @returns text
         */
        async function decompress(compressedHexText) {

            const buffer = convertHexToBuffer(compressedHexText);

            const readStream = new Response(buffer);
            const decompressedReadableStream = readStream.body.pipeThrough(new DecompressionStream('gzip'))
            const response = new Response(decompressedReadableStream);

            const text = await response.text();

            return text;
        }

        /**
         * text compress decompress
         */
        async function testHextText() {
            // input text
            const snapshotText = getConfigurationSnapshotJsonText(gconfiguration);
            console.log(snapshotText);

            const compressedText = await compress(snapshotJsonText);
            console.log(compressedText);

            const decompressedText = await decompress(compressedText);
            console.log(decompressedText);

            // should be able to decompress
            const equal = snapshotJsonText === decompressedText
            console.log(equal);

            if (!equal) {
                throw new Error("compress does not decompress");
            }
        }

        /**
         * button
         */
        async function loadConfigurationUrlHash() {
            // # comes after the url

            // remove #
            const compressedText = window.location.hash.substring(1);
            const decompressedText = await decompress(compressedText);
            loadConfigurationTextJson(decompressedText);
        }

        /**
         * button 
         */
        async function saveConfigurationUrlHash() {
            // translate configuration to hash
            // snapshot current state
            const snapshotJsonText = getConfigurationSnapshotJsonText(gconfiguration);
            console.log(snapshotJsonText);

            const compressedText = await compress(snapshotJsonText);
            console.log(compressedText);

            // set to hash at top of window
            window.location.hash = compressedText;
        }


        function drawConfiguration(configuration, canvas) {
            canvas.width = 200;
            canvas.height = 200;
            const context = canvas.getContext("2d");

            const { title, description, items, state } = configuration;

            context.font = '14px serif';
            context.textBaseline = "bottom"; //"alphabetic"; 

            const measure = context.measureText(title);
            const height = measure.fontBoundingBoxAscent + measure.fontBoundingBoxDescent;

            // write out title
            context.fillText(title, 0, height);

            // Draw all of the configuration settings on the canvas

            const spacing = height + 10;
            let y = spacing;
            let x = 10;
            const checkboxSize = 10;

            items.forEach(({id, title, input}) => {
                if (input === "checkbox") {
                    // draw the checkbox
                    const value = state === undefined ? undefined : state[id];

                    context.fillRect(x, y, checkboxSize, checkboxSize);

                    // increae offset
                    y += spacing;

                }
            });

            // Determine how checkbox is drawn


            context.fillStyle = "#FF0000";
            context.fillRect(0, 0, 10, 10);

        }

        /**
         * button
         */
        function saveConfigurationImage() {
            // draw the configuration on a canvas

            const canvas = document.createElement("canvas");
            drawConfiguration(gconfiguration, canvas);


            // for testing purposes allow preview of the canvas
            const div = document.getElementById("div_configuration_canvas");
            // reset
            div.innerText = "";
            div.appendChild(canvas);


            // save the canvas
            // same as saving json
        }

        /**
         * currently loaded configuration
         */
        let gconfiguration = undefined;


        /**
         * Only function run on start
         * Set up everything, link all UI elements
         */
        function initialize() {
            // Initial configuration
            loadConfigurationTextMarkdown(defaultConfigurationMarkdown);

            // Start - Test
            // Test Code to run at start
            saveConfigurationImage();
            // End - Test

            document.getElementById("button_save_file").onclick = saveSnapshotJsonTextFile;

            const input_file = document.getElementById("input_load_file");
            input_file.onchange = async () => {
                const files = input_file.files;
                loadConfigurationFile(files)
            };

            document.getElementById("button_save_url").onclick = saveConfigurationUrlHash;
            document.getElementById("button_load_url").onclick = loadConfigurationUrlHash;

            document.getElementById("button_save_image").onclick = saveConfigurationImage;
        }

        initialize();

    </script>
</body>

</html>