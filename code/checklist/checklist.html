<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Checklist</title>
</head>

<body>

    <!--
        Generate a configurable list layout with clickable boxes and allow export to an image

        Allow export and sharing via URL

        Pieces:

        Configuration
            - The `configuration` is the set, layout, and state of possible items.     
            - fixed set of item options
                - checkbox
                - likert - future
            - hostable and pointable on any URL
                - determine which parser to use based off .md or .json suffix

        load only
            - markdown template (more easily viewable and editable than json)

        save / load
            - json configuration (allows saving to local file system)
            - compressed hex url hash (allows sharing link)
            - TODO: image (render selection for reference and share, and load from image via embedded state)

        Save / Load methods
            loadConfiguration


        HTML Render and Selection

        Everything loaded is a configuration
            - markdown configuration is a template
            - json or URL configurations include answers

        edit
            - probably want a way to edit inline

        Canvas Draw and Image Export / Download
            - possible via screen capture?
            - steganography embedd compressed information into the image since programs remove metadata, also embedd the metadata
            - RGBA can tack on at the end, but still need the total length of data to read

        Styling
            - will need to style so it looks appealing

        Features
            - encode hash to make it harder for people to tamper with to check that image is actual representation, could also compare image to value but then this changes if svg encoding changes between versions.


        Principles:
            - hostable anywhere - self contained HTML page
            - sharable and private
                - no telemetry
                - no storage or persistance of data outside of users machine
            - configurable and customizable, with sharable configurations
            - machine parsable if shared
            - secure
                - do not want to allow links that people can click, except to know safe domains (maybe wikipedia links are ok?)
                - defend against HTML injection from input sources
            - compatible this means old configurations and renders continue to work
                - can be done by versioning, point to specific HTML page
                - or keep everything backwards compatible and have shim layers that translate to new logic based on an embedded version number
    
        Reference
        https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input/checkbox
        https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file
        https://developer.mozilla.org/en-US/docs/Web/API/File

        https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas

        https://motdave.com/page-https-developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications
    
            -->
    <button id="button_save_url">Save URL</button>
    <button id="button_load_url">Load URL</button>
    <br>

    <p>Save File</p>
    <button id="button_save_file_json">json</button>
    <button id="button_save_file_text">text</button>
    <button id="button_save_file_svg">svg</button>
    <br>
    <br>
    <label for="input_load_file">Load json or md configuration</label>
    <input id="input_load_file" type="file" accept=".json,.md,.txt">

    <!-- Configuration Placeholder with actual actions -->

    <div id="div_configuration"></div>

    <br>
    <!-- Div to contain the canvas for the image, shown for testing purposes -->
    <div id="div_configuration_canvas"></div>

    <br>
    <div id="div_configuration_svg"></div>

    <script>


        // Example actually use markdown as all input
        const defaultConfigurationJson = {
            title: "example configuration title",
            description: "example configuration description",

            // All independent items
            items: [
                // items and order they appear in
                {
                    // id is derivable from title in md but must be specified in json
                    id: "example_checkbox_item_title",
                    title: "example checkbox item title",
                    description: "example checkbox item description",
                    input: "checkbox"
                }
            ],

            // layout
            // probably want a separate layout section that can determine how items are layed out
            // maybe sections and subsections with their own titles and descriptions
            // should these sections be infinitely nestable?
            // do section titles become part of the item id? Probably yes when layed out with markdown

            // state of all items
            // id -> value
            // id should be present in the items
            // value is dependent on the item type
            // empty assumes default value
            state: {
                // by default empty
            }

        }

        // whitespace matters
        const defaultConfigurationMarkdown = `
# example title
> example description

- [ ] example item
    > example item description
- [x] example item
    > example item description duplicate
- [ ] example item other
    > example item description

`;

        /**
         * create json configuration from a markdown description
         */
        function parseMarkdownToConfiguration(markdownInput) {
            const markdown = markdownInput.trim()

            const lines = markdown.split("\n");
            // Could scrub empty lines for utility, but then need a mapping of lines to orignal line numbers for errors

            /**
             * Title for the whole list
             */
            let listTitle = undefined;

            /**
             * description for the whole list
             */
            let listDescription = undefined;

            /**
             * items in the list
             * Each item has
             * - title
             * - description
             * - input- the type of input 
             */
            const listItems = [];

            /**
             * state of each item
             */
            const state = {};


            const itemIds = [];

            // Delimiters
            const delimiterListTitle = "# ";
            const delimiterListDescription = "> ";
            const delimiterListItemCheckboxUnchecked = "- [ ] ";
            const delimiterListItemCheckboxChecked = "- [x] ";
            const delimiterListItemDescription = "    > ";



            for (let i = 0; i < lines.length; i++) {
                // Get all lines before and after
                const linePrevious = i > 0 ? lines[i - 1] : undefined;
                const line = lines[i];
                const lineNext = i + 1 < lines.length ? lines[i + 1] : undefined;
                //console.log(line);

                const isListItemCheckboxUnchecked = line.startsWith(delimiterListItemCheckboxUnchecked);
                const isListItemCheckboxChecked = line.startsWith(delimiterListItemCheckboxChecked);

                const isListItemCheckbox = isListItemCheckboxUnchecked || isListItemCheckboxChecked;

                // parse the line
                if (line.startsWith(delimiterListTitle)) {
                    // List Title
                    if (listTitle === undefined) {
                        listTitle = line.substring(delimiterListTitle.length).trim();
                    } else {
                        console.error(`line [${i}]: duplicate list title - only a single list title may be defined`);
                    }

                    // List Description
                    // Must be next line after title
                    if (lineNext !== undefined && lineNext.startsWith(delimiterListDescription)) {
                        listDescription = lineNext.substring(delimiterListDescription.length).trim();
                        // already parsed line go to next
                        i++;
                    }

                } else if (isListItemCheckbox) {
                    // List Item Checkbox

                    const itemTitle = line.substring(delimiterListItemCheckboxUnchecked.length).trim();
                    const itemInput = "checkbox";
                    let itemDescription = undefined;

                    if (lineNext !== undefined && lineNext.startsWith(delimiterListItemDescription)) {
                        // List Item Description
                        itemDescription = lineNext.substring(delimiterListItemDescription.length).trim();

                        // Already parsed the line go to next
                        i++;
                    }

                    // mapping is imperfect since it filters characters
                    const itemBaseId = titleToId(itemTitle);
                    const itemId = toUniqueId(itemBaseId, itemIds);
                    itemIds.push(itemId);

                    state[itemId] = isListItemCheckboxChecked;

                    listItems.push({
                        id: itemId,
                        title: itemTitle,
                        description: itemDescription,
                        input: itemInput,
                    });

                } else {
                    // Unknown What is this?
                    if (line !== "") {
                        console.error(`line [${i}]: unknown value [${line}]`);
                    }
                }
            }

            // Assemble configuration Json
            const configurationJson = {
                title: listTitle,
                description: listDescription,
                items: listItems,
                state,
            }

            return configurationJson;
        }

        /**
         * Map item title to id
         * id can only consist of lowercase letters, numbers, and underscores
         * converts uppercase to lowercase
         * removes duplicate spaces and replaces the space with an underscore
         */
        function titleToId(title) {
            const characters = Array.from(title.toLowerCase());

            // characters allowed in an identifier
            const alphabet = "abcdefghijklmnopqrstuvwxyz";
            const numbers = "0123456789"
            const space = " "

            const valid = alphabet + numbers + space;

            const validCharacters = Array.from(valid);

            // filter out invalid characters, remove duplicate spaces, map spaces to underscores
            const idArray = characters
                .filter((c) => validCharacters.includes(c))
                .filter((c, index, array) =>
                    // no duplicate spaces
                    c !== space || (c === space && index - 1 >= 0 && array[index - 1] !== space)
                ).map((c) => c === space ? "_" : c);

            const id = idArray.join("");
            return id;
        }

        /**
         * create unique id based off a baseId, given the set of existing Ids
         */
        function toUniqueId(baseId, existingIds) {
            let itemId = baseId;

            // id must not already be present
            // if id is already present attach a numeric count to the end to make it unique
            let idCount = 0;
            while (-1 !== existingIds.findIndex((id) => id === itemId)) {
                idCount++;
                itemId = baseId + "_" + idCount;
            }

            return itemId;
        }

        /**
         * currently loaded configuration
         * should only be used by loadConfiguration and getConfigurationSnapshot
         */
        let gconfiguration = undefined;

        function loadConfiguration(configuration) {
            console.log("loadConfiguration");
            console.log(configuration);
            loadConfigurationToHtml(configuration);
            gconfiguration = configuration;
        }

        /**
         * load the configuration to html on the pace so it can be manipulated
         * include state informtion
         */
        function loadConfigurationToHtml(configuration) {

            const div = document.getElementById("div_configuration");
            // reset everything in the div, (otherwise end up with duplicate elements on subsequent loads)
            div.innerText = "";

            const { title, description, items, state } = configuration;

            const defaultTitle = "List";
            const defaultDescription = "";

            const listTitle = title || defaultTitle;

            const elementListTitle = document.createElement("h1");
            elementListTitle.innerText = listTitle;

            const elementListDescription = document.createElement("p");
            elementListDescription.innerText = description || defaultDescription;

            document.title = listTitle;

            div.appendChild(elementListTitle);
            div.appendChild(elementListDescription);

            // append all list elements
            const children = items.map(({ id, title, description, input }) => {

                const elementDiv = document.createElement("div");

                // determine input type
                // why not aimply assign? - security plus elements have different needs
                if (input === "checkbox") {
                    const elementInput = document.createElement("input");
                    elementInput.type = "checkbox";
                    elementInput.name = title;
                    elementInput.id = id;

                    // use preserved state
                    if (state && state[id] && typeof state[id] === "boolean") {
                        elementInput.checked = state[id]
                    }

                    const elementLabel = document.createElement("label");
                    elementLabel.for = id;
                    elementLabel.innerText = title;

                    elementDiv.appendChild(elementInput);
                    elementDiv.appendChild(elementLabel);

                } else {
                    console.error(`invalid type for item [${input}]`);
                    const p = document.createElement("p");
                    p.innerText = `item [${name}] invalid type [${input}] for item`;
                    elementDiv.appendChild(p);
                }

                return elementDiv;

            });

            div.append(...children);

        }

        /**
         * Get a snapshot of the current global configuration
         * a snapshot is simply a configuration with the current state of the HTML attached
         */
        function getConfigurationSnapshot() {
            const configuration = gconfiguration;

            // clone configuration
            const snapshot = JSON.parse(JSON.stringify(configuration));

            // empty state
            snapshot["state"] = {};

            // retrieve current state and bind it to the snapshot
            snapshot.items.forEach(({ id, input }) => {
                const element = document.getElementById(id);
                if (element) {
                    if (input === "checkbox") {
                        const checked = element.checked;
                        snapshot.state[id] = checked;
                    }
                }
            });

            return snapshot
        }

        function assertString(variable) {
            if (typeof variable !== 'string') {
                throw new TypeError('variable must be a string')
            }
        }

        /**
         * check that string is only made up of valid characters
         * @param check - string to check
         * @param valid - string of valid characters
         */
        function assertStringRange(check, valid) {
            assertString(check);
            assertString(valid);

            const validCharacters = Array.from(valid);

            // filter out invalid characters, remove duplicate spaces, map spaces to underscores
            const invalid = Array.from(check).filter((c) => !validCharacters.includes(c));
            if (invalid.length > 0) {
                throw new RangeError(`Invalid characters in string: [${invalid.join("")}]`);
            }
        }

        /**
         * converts an ArrayBuffer to hexText
         * @param buffer - ArrayBuffer
         */
        function convertBufferToHex(buffer) {
            // https://stackoverflow.com/questions/40031688/javascript-arraybuffer-to-hex
            return [...new Uint8Array(buffer)]
                .map(x => x.toString(16).padStart(2, '0'))
                .join('');
        }

        /**
         * converts hexText to ArrayBuffer
         */
        function convertHexToBuffer(hexText) {
            assertString(hexText);
            assertStringRange(hexText, "0123456789abcdef");

            if ((hexText.length % 2) !== 0) {
                throw new RangeError('hexText must be an even number of characters');
            }

            const view = new Uint8Array(hexText.length / 2)

            let index = 0;
            for (let i = 0; i < hexText.length; i += 2) {
                // next pair of hex characters
                // two hex characters, 8 bits
                const pair = hexText.substring(i, i + 2);
                const bits = parseInt(pair, 16);

                // insert bits into the buffer at the next position
                view[index] = bits
                index++;
            }

            const buffer = view.buffer;

            return buffer;
        }

        /**
         * converts text to gzip compressed hexText
         * @param text - a string
         * @returns gzip compressed hexText
         */
        async function compress(text) {
            // https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream

            const readStream = new Response(text);
            const compressedReadableStream = readStream.body.pipeThrough(new CompressionStream('gzip'));
            const response = new Response(compressedReadableStream);

            const buffer = await response.arrayBuffer();
            const compressedHexText = convertBufferToHex(buffer);
            return compressedHexText;
        }

        /**
         * converts gzip compressed hexText to text
         * @param compressedHexText - gzip compressed hexText
         * @returns text
         */
        async function decompress(compressedHexText) {

            const buffer = convertHexToBuffer(compressedHexText);

            const readStream = new Response(buffer);
            const decompressedReadableStream = readStream.body.pipeThrough(new DecompressionStream('gzip'))
            const response = new Response(decompressedReadableStream);

            const text = await response.text();

            return text;
        }



        /**
         * convert configuration to json text
         */
        function getConfigurationToTextJson(configuration, { pretty } = { pretty: false }) {
            // pretty option adds spaces for readability
            const text = pretty ? JSON.stringify(configuration, undefined, "    ") : JSON.stringify(configuration);
            return text;
        }

        /**
         * get a configuration from json text
         */
        function getConfigurationFromTextJson(text) {
            const configuration = JSON.parse(text);
            return configuration;
        }

        /**
         * get a configuration from hex text (compressed json text)
         */
        async function getConfigurationFromTextHex(text) {
            const decompressedText = await decompress(text);
            const configuration = getConfigurationFromTextJson(decompressedText);
            return configuration;
        }

        /**
         * get a configuration from markdown text
         */
        function getConfigurationFromTextMarkdown(text) {
            const configuration = parseMarkdownToConfiguration(text);
            console.log(configuration);
            return configuration;
        }

        async function getConfigurationFromFile(name, text) {
            let configuration = undefined;

            // load differently based on the file extension
            const nameLowercase = name.toLowerCase();

            if (nameLowercase.endsWith(".json")) {
                configuration = getConfigurationFromTextJson(text);
            } else if (nameLowercase.endsWith(".md")) {
                configuration = getConfigurationFromTextMarkdown(text);
            } else if (nameLowercase.endsWith(".txt")) {
                configuration = getConfigurationFromTextHex(text);
            }
            // TODO: Support SVG

            return configuration;

        }

        /**
         * download a file by inserting a link element with the url containing the encoding
         */
        function downloadFileUrl({ filename, url }) {
            const element = document.createElement('a');

            element.setAttribute('href', url);
            element.setAttribute('download', filename);
            element.click();
        }

        /**
         * download file
         * @param filename - name of the file to download
         * @param text - contents of the text file utf-16 text
         * @param encoding - mime type of the file
         */
        function downloadFile({ filename, text, encoding }) {
            const blob = new Blob([text], {type:encoding})
            const downloadUrl = URL.createObjectURL(blob);
            console.log(downloadUrl)
            downloadFileUrl({ filename, url: downloadUrl });
            URL.revokeObjectURL(downloadUrl);

            // legacy
            // const component = encodeURIComponent(text);
            // const url = `${encoding};charset=utf-16, ` + component;
            // downloadFileUrl({filename, url})
        }

        async function buttonLoadSnapshotFromFile(files) {
            if (files.length !== 1) {
                console.error(`can only load a single file`);
                return;
            }

            const file = files[0];
            const name = file.name;
            const text = await file.text();

            const configuration = await getConfigurationFromFile(name, text);

            if (configuration === undefined) {
                console.error(`unable to load file extension ${name}`);
            } else {
                loadConfiguration(configuration);
            }
        }

        /**
         * text compress decompress
         */
        async function testHexText() {
            // input text
            const configuration = getConfigurationSnapshot();
            const snapshotText = getConfigurationToTextJson(configuration);
            console.log(snapshotText);

            const compressedText = await compress(snapshotJsonText);
            console.log(compressedText);

            const decompressedText = await decompress(compressedText);
            console.log(decompressedText);

            // should be able to decompress
            const equal = snapshotJsonText === decompressedText
            console.log(equal);

            if (!equal) {
                throw new Error("compress does not decompress");
            }
        }


        async function getConfigurationToTextHex(configuration) {
            const snapshotJsonText = getConfigurationToTextJson(configuration);
            //console.log(snapshotJsonText);

            const compressedText = await compress(snapshotJsonText);
            //console.log(compressedText);
            return compressedText;
        }


        /**
         * canvas is a bit pixelated
         */
        function drawConfigurationCanvas(configuration, canvas) {
            canvas.width = 200;
            canvas.height = 200;
            const context = canvas.getContext("2d");

            const { title, description, items, state } = configuration;

            context.font = '20px serif';
            context.textBaseline = "alphabetic"; //"alphabetic"; 

            const checkboxSize = 10;
            const checkboxColor = "#000000"; // black
            const textColor = "#000000";

            const measure = context.measureText(title);
            const height = measure.fontBoundingBoxAscent + measure.fontBoundingBoxDescent;

            // write out title
            context.fillText(title, 0, height);

            // Draw all of the configuration settings on the canvas

            const spacing = height + 10;
            let y = spacing;
            let x = 10;



            items.forEach(({ id, title, input }) => {
                if (input === "checkbox") {
                    // draw the checkbox
                    const value = state === undefined ? undefined : state[id];

                    // checkbox
                    // rectangle draws down from the top left x, y
                    context.fillStyle = value ? checkboxColor : "#FFFFFF";
                    context.fillRect(x, y, checkboxSize, checkboxSize);

                    // text
                    // text draws from the left bottom x y
                    const dx = checkboxSize + 10;
                    const dy = checkboxSize;
                    context.fillStyle = textColor;
                    context.fillText(title, x + dx, y + dy);

                    // dot
                    context.fillStyle = "#FF0000";
                    context.fillRect(0, 0, 1, 1);

                    // increase offset
                    y += spacing;

                }
            });

            // Determine how checkbox is drawn

        }

        function saveConfigurationImageCanvas(configuration) {
            const canvas = document.createElement("canvas");
            drawConfigurationCanvas(configuration, canvas);


            // for testing purposes allow preview of the canvas
            const div = document.getElementById("div_configuration_canvas");
            // reset
            div.innerText = "";
            div.appendChild(canvas);
        }


        /**
         * @param x - x of lower left corner
         * @param y - y of lower left corner
         * @param text - the text to write
         */
        function createSvgTextElement(x, y, text) {
            const textElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'text'
            );

            textElement.setAttribute("x", x);
            textElement.setAttribute("y", y);

            textElement.setAttribute("alignment-baseline", "baseline");

            // TODO: sanitize the text
            const textNode = document.createTextNode(text);
            textElement.appendChild(textNode);

            return textElement;

        }

        /**
         * @param x - x of upper left corner
         * @param y - y of upper left corner
         * @param checkboxSize - width and height of the checkbox
         * @param checked - is the checkbox checked
         */
        function createSvgCheckboxElement(x, y, checkboxSize, checked) {

            const rectElement = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'rect'
            );

            rectElement.setAttribute("x", x);
            rectElement.setAttribute("y", y);

            rectElement.setAttribute("width", checkboxSize);
            rectElement.setAttribute("height", checkboxSize);


            const color = checked ? "black" : "white";
            rectElement.setAttribute("style", `fill:${color}`);

            return rectElement;
        }

        // sweet sweet SVGs! Pixel perfection!
        function getConfigurationToSvgElement(configuration) {
            const { title, description, items, state } = configuration;

            const checkboxSize = 10;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            //svg.setAttribute("viewbox", "0 0 100 100");
            svg.setAttribute("width", 200);
            svg.setAttribute("height", 200);


            const height = 20; // need to measure height of text
            let y = height;
            let x = 0;

            // title
            svg.appendChild(createSvgTextElement(x, y, title));

            const spacing = height + 10;
            y = spacing;
            x = 10;


            items.forEach(({ id, title, input }) => {
                if (input === "checkbox") {
                    // draw the checkbox
                    const value = state === undefined ? undefined : state[id];

                    // checkbox
                    // rectangle draws down from the top left x, y
                    const checkboxElement = createSvgCheckboxElement(x, y, checkboxSize, value);
                    svg.appendChild(checkboxElement);

                    // text
                    // text draws from the left bottom x y
                    const dx = checkboxSize + 10;
                    const dy = checkboxSize;
                    const textElement = createSvgTextElement(x + dx, y + dy, title);
                    svg.appendChild(textElement);

                    // increase offset
                    y += spacing;

                }
            });


            return svg;

        }


        function saveConfigurationImageSvg(configuration) {

            // for testing purposes allow preview on the canvas
            const div = document.getElementById("div_configuration_svg");

            const svg = getConfigurationToSvgElement(configuration);

            // reset
            div.innerText = "";
            div.appendChild(svg);
        }


        //
        // UI callable methods
        //

        /**
         * button
         */
        async function buttonLoadSnapshotFromUrlHash() {
            // # comes after the url
            // remove #
            const text = window.location.hash.substring(1);
            const configuration = await getConfigurationFromTextHex(text);
            loadConfiguration(configuration);
        }

        /**
         * button 
         */
        async function buttonSaveSnapshotToUrlHash() {
            const configuration = getConfigurationSnapshot();
            const text = await getConfigurationToTextHex(configuration)

            // set to hash at top of window
            window.location.hash = text;
        }

        /**
         * button 
         * get snapshot of the current configurations answers and save to JSON
         */
        function buttonSaveSnapshotToFileJson() {
            const configuration = getConfigurationSnapshot();

            const filename = `${configuration.title}.json`;
            const text = getConfigurationToTextJson(configuration, { pretty: true });
            const encoding = 'data:text/plain';
            downloadFile({ filename, text, encoding });
        }

        /**
         * button 
         * get snapshot of the current configurations answers and save to svg
         */
        function buttonSaveSnapshotToFileSvg() {
            const configuration = getConfigurationSnapshot();

            const svg = getConfigurationToSvgElement(configuration);
            var serializer = new XMLSerializer();
            var snapshotSvgText = serializer.serializeToString(svg);

            const filename = `${configuration.title}.svg`;
            const text = snapshotSvgText;
            const encoding = 'data:image/svg+xml';
            downloadFile({ filename, text, encoding });
        }

        /**
         * button 
         * get snapshot of the current configurations answers and save to svg
         */
        async function buttonSaveSnapshotToFileTextHex() {
            const configuration = getConfigurationSnapshot();

            const filename = `${configuration.title}.txt`;
            const text = await getConfigurationToTextHex(configuration);
            const encoding = 'data:text/plain';
            downloadFile({ filename, text, encoding });
        }

        /**
         * button
         */
        function drawConfigurationImage() {
            //buttonSaveSnapshotToFileSvg();

            const configuration = getConfigurationSnapshot()

            // draw the configuration on a canvas
            saveConfigurationImageCanvas(configuration);

            // draw the configuration as an svg
            saveConfigurationImageSvg(configuration);


            // save the canvas
            // same as saving json
        }

        /**
         * Only function run on start
         * Set up everything, link all UI elements
         */
        function initialize() {
            // Initial configuration
            const configuration = getConfigurationFromTextMarkdown(defaultConfigurationMarkdown);
            loadConfiguration(configuration);

            // Start - Test
            // Test Code to run at start
            drawConfigurationImage()
            // End - Test

            document.getElementById("button_save_url").onclick = buttonSaveSnapshotToUrlHash;
            document.getElementById("button_load_url").onclick = buttonLoadSnapshotFromUrlHash;

            document.getElementById("button_save_file_json").onclick = buttonSaveSnapshotToFileJson;
            document.getElementById("button_save_file_text").onclick = buttonSaveSnapshotToFileTextHex;
            document.getElementById("button_save_file_svg").onclick = buttonSaveSnapshotToFileSvg;

            // Load file
            const input_file = document.getElementById("input_load_file");
            input_file.onchange = async () => {
                const files = input_file.files;
                await buttonLoadSnapshotFromFile(files)
            };
        }

        initialize();

    </script>
</body>

</html>